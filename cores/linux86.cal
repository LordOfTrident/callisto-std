## Supported features: IO, Exit, Time, File
##
## Cell size = 64 bits

inline __linux86_pop_rdi begin asm
	"sub r15, 8"
	"mov rdi, [r15]"
end end

inline __linux86_pop_rsi begin asm
	"sub r15, 8"
	"mov rsi, [r15]"
end end

inline __linux86_pop_rax begin asm
	"sub r15, 8"
	"mov rax, [r15]"
end end

inline __linux86_pop_rbx begin asm
	"sub r15, 8"
	"mov rbx, [r15]"
end end

inline __linux86_pop_rcx begin asm
	"sub r15, 8"
	"mov rcx, [r15]"
end end

inline __linux86_pop_rdx begin asm
	"sub r15, 8"
	"mov rdx, [r15]"
end end

inline __linux86_pop_r10 begin asm
	"sub r15, 8"
	"mov r10, [r15]"
end end

inline __linux86_pop_r9 begin asm
	"sub r15, 8"
	"mov r9, [r15]"
end end

inline __linux86_pop_r8 begin asm
	"sub r15, 8"
	"mov r8, [r15]"
end end

inline __linux86_push_rax begin asm
	"mov [r15], rax"
	"add r15, 8"
end end

inline __linux86_push_rbx begin asm
	"mov [r15], rbx"
	"add r15, 8"
end end

inline __linux86_push_rdx begin asm
	"mov [r15], rdx"
	"add r15, 8"
end end

version IO
	func printch begin asm
		"sub r15, 8"
		"mov rsi, r15"
		"mov rax, 1"
		"mov rdi, 1"
		"mov rdx, 1"
		"syscall"
	end end
end

version Exit
	func exit begin
		__linux86_pop_rdi
		asm
			"mov rax, 60"
			"syscall"
		end
	end
end

func = begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"cmp rax, rbx"
		"je .push_1"
		"mov qword [r15], 0"
		"add r15, 8"
		"ret"
		".push_1:"
		"mov qword [r15], 0xFFFFFFFFFFFFFFFF"
		"add r15, 8"
	end
end

func > begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"cmp rax, rbx"
		"jg .push_1"
		"mov qword [r15], 0"
		"add r15, 8"
		"ret"
		".push_1:"
		"mov qword [r15], 0xFFFFFFFFFFFFFFFF"
		"add r15, 8"
	end
end

func >= begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"cmp rax, rbx"
		"jge .push_1"
		"mov qword [r15], 0"
		"add r15, 8"
		"ret"
		".push_1:"
		"mov qword [r15], 0xFFFFFFFFFFFFFFFF"
		"add r15, 8"
	end
end

func < begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"cmp rax, rbx"
		"jl .push_1"
		"mov qword [r15], 0"
		"add r15, 8"
		"ret"
		".push_1:"
		"mov qword [r15], 0xFFFFFFFFFFFFFFFF"
		"add r15, 8"
	end
end

func <= begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"cmp rax, rbx"
		"jle .push_1"
		"mov qword [r15], 0"
		"add r15, 8"
		"ret"
		".push_1:"
		"mov qword [r15], 0xFFFFFFFFFFFFFFFF"
		"add r15, 8"
	end
end

func @ begin
	__linux86_pop_rbx
	asm
		"mov rax, [rbx]"
	end
	__linux86_push_rax
end

func ! begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"mov [rbx], rax"
	end
end

func b@ begin
	__linux86_pop_rbx
	asm
		"xor rax, rax"
		"mov al, [rbx]"
	end
	__linux86_push_rax
end

func b! begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"mov [rbx], al"
	end
end

func w@ begin
	__linux86_pop_rbx
	asm
		"xor rax, rax"
		"mov ax, [rbx]"
	end
	__linux86_push_rax
end

func w! begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"mov [rbx], ax"
	end
end

func d@ begin
	__linux86_pop_rbx
	asm
		"xor rax, rax"
		"mov eax, [rbx]"
	end
	__linux86_push_rax
end

func d! begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"mov [rbx], eax"
	end
end

func dup begin
	__linux86_pop_rax
	__linux86_push_rax
	__linux86_push_rax
end

func drop begin asm
	"sub r15, 8"
end end

func swap begin
	__linux86_pop_rbx
	__linux86_pop_rax
	__linux86_push_rbx
	__linux86_push_rax
end

func + begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"add rax, rbx"
	end
	__linux86_push_rax
end

func s+ begin + end

func - begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"sub rax, rbx"
	end
	__linux86_push_rax
end

func s- begin - end

func * begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"mul rbx"
	end
	__linux86_push_rax
end

func s* begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"imul rbx"
	end
	__linux86_push_rax
end

func / begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"xor rdx, rdx"
		"div rbx"
	end
	__linux86_push_rax
end

func s/ begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"xor rdx, rdx"
		"idiv rbx"
	end
	__linux86_push_rax
end

func % begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"xor rdx, rdx"
		"div rbx"
	end
	__linux86_push_rdx
end

func s% begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"xor rdx, rdx"
		"idiv rbx"
	end
	__linux86_push_rdx
end

func and begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"and rax, rbx"
	end
	__linux86_push_rax
end

func or begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"or rax, rbx"
	end
	__linux86_push_rax
end

func xor begin
	__linux86_pop_rbx
	__linux86_pop_rax
	asm
		"xor rax, rbx"
	end
	__linux86_push_rax
end

func not begin
	__linux86_pop_rax
	asm
		"not rax"
	end
	__linux86_push_rax
end

func << begin
	__linux86_pop_rcx
	__linux86_pop_rax
	asm
		"shl rax, cl"
	end
	__linux86_push_rax
end

func >> begin
	__linux86_pop_rcx
	__linux86_pop_rax
	asm
		"shr rax, cl"
	end
	__linux86_push_rax
end

version Time
	func get_epoch_time begin
		asm
			"mov rax, 201" # time syscall
			"xor rdi, rdi"
			"syscall"
		end
		__linux86_push_rax # stuff is returned with rax right?
	end
end

version File
	const FILE_READ  1
	const FILE_WRITE 2
	const SEEK_SET   0
	const SEEK_CUR   1
	const SEEK_END   2
	const __linux86_const_O_RDONLY 0
	const __linux86_const_O_WRONLY 1
	const __linux86_const_O_RDWR   2
	const __linux86_const_O_CREAT  64
	const __linux86_const_S_IRUSR  256
	const __linux86_const_S_IWUSR  128

	alias __linux86_dev_t     u64
	alias __linux86_ino_t     u64
	alias __linux86_mode_t    u32
	alias __linux86_nlink_t   u64
	alias __linux86_uid_t     u32
	alias __linux86_gid_t     u32
	alias __linux86_off_t     u64
	alias __linux86_time_t    u64
	alias __linux86_blksize_t u64
	alias __linux86_blkcnt_t  u64

	struct __linux86_stat
		u64 st_dev
		u64 st_ino
		u64 st_nlink
		u32 st_mode
		u32 st_uid
		u32 st_gid
		u32 padding
		u64 st_rdev
		u64 st_size
		u64 st_blksize
		u64 st_blocks
		u64 st_atime
		u64 padding1
		u64 st_mtime
		u64 st_ctime
		array 24 u8 pad
	end

	struct File
		cell fd
	end

	let File stdin
	let File stdout
	let File stderr
	0 stdin !
	1 stdout !
	2 stderr !

	func __linux86_create_file begin
		# Path
		__linux86_pop_rdi
		# Flags
		__linux86_const_O_CREAT __linux86_pop_rsi
		# Mode
		__linux86_const_S_IWUSR __linux86_const_S_IRUSR or __linux86_pop_rdx
		asm
			"mov rax, 2" # Open
			"syscall"
			"mov rdi, rax"
			"mov rax, 3" # Close
			"syscall"
		end
	end

	func open_file begin
		let addr path
		let cell mode
		mode !
		path !

		let array 4096 u8 pathBytes
		let cell i
		let addr src
		let addr dest
		let cell flags
		0 i !

		path @ Array.elements + @ src !
		pathBytes dest !

		while i @ path @ @ < do
			src @ b@ dest @ b!

			i @ 1 + i !
			src @ 1 + src !
			dest @ 1 + dest !
		end

		# just in case
		0 pathBytes 4095 + b!

		let cell modeFlag

		if FILE_READ FILE_WRITE and mode @ = then
			pathBytes __linux86_create_file
			__linux86_const_O_RDWR modeFlag !
		elseif FILE_READ mode @ = then
			__linux86_const_O_RDONLY modeFlag !
		elseif FILE_WRITE mode @ = then
			pathBytes __linux86_create_file
			__linux86_const_O_WRONLY modeFlag !
		end

		pathBytes
		flags @
		modeFlag @ or

		__linux86_pop_rsi
		__linux86_pop_rdi
		asm
			"mov rax, 2" # open syscall
			"xor rdx, rdx"
			"syscall"
		end
	end

	func close_file begin
		@ __linux86_pop_rdi # FD
		asm
			"mov rax, 3" # Close
			"syscall"
		end
	end

	func file< begin
		!
	end

	func file@ begin
		__linux86_pop_rdx   # Length
		__linux86_pop_rsi   # Buffer
		@ __linux86_pop_rdi # Fd

		asm
			"mov rax, 0" # read
			"syscall"
		end
	end

	func file! begin
		__linux86_pop_rdx   # Length
		__linux86_pop_rsi   # Buffer
		@ __linux86_pop_rdi # Fd

		asm
			"mov rax, 1" # write
			"syscall"
		end

		__linux86_push_rax
	end

	func file_seek begin
		__linux86_pop_rdx
		__linux86_pop_rsi
		@ __linux86_pop_rdi

		asm
			"mov rax, 8" # lseek
			"syscall"
		end
	end

	func file_peek begin
		@ __linux86_pop_rdi
		asm
			"mov rdx, 1" # SEEK_CUR
			"xor rsi, rsi"
			"mov rax, 8" # lseek
			"syscall"
		end
		__linux86_push_rax
	end
end

version Args
	version LibC
		func core_get_arg begin
			8 * __linux86_argv @ + @
		end
	end

	version not LibC
		func core_get_arg begin
			let cell which
			let cell counter
			let addr args
			dup which !
			counter !
			__linux86_argv @ args !

			if which @ 0 = then args @ return end

			while true do
				if args @ b@ 0 = then
					counter @ 1 - counter !

					if counter @ 0 = then args @ 1 + return end
				end

				args @ 1 + args !
			end
		end
	end

	inline core_get_arg_length begin __linux86_argc @ end
end

version Heap
	version LibC
		extern C addr malloc usize end
		extern C void free addr end
	end

	version not LibC
		const __linux86_PROT_READ     1
		const __linux86_PROT_WRITE    2
		const __linux86_MAP_PRIVATE   2
		const __linux86_MAP_ANONYMOUS 32
		const __linux86_MREMAP_MAYMOVE 1
		const __linux86_MREMAP_FIXED   2

		func __linux86_mmap begin
			__linux86_pop_r9  # pgoff
			__linux86_pop_r8  # fd
			__linux86_pop_r10 # flags
			__linux86_pop_rdx # prot
			__linux86_pop_rsi # len
			__linux86_pop_rdi # addr

			asm
				"mov rax, 9" # mmap syscall
				"syscall"
			end

			__linux86_push_rax
		end

		func malloc begin
			let cell sz
			sz !

			0 sz @ 8 + __linux86_PROT_READ __linux86_PROT_WRITE or
			__linux86_MAP_PRIVATE __linux86_MAP_ANONYMOUS or -1 0 __linux86_mmap

			dup sz @ swap ! # write size
			8 +
		end

		func __linux86_mremap begin
			__linux86_pop_r8  # new_addr
			__linux86_pop_r10 # flags
			__linux86_pop_rdx # new_len
			__linux86_pop_rsi # old_len
			__linux86_pop_rdi # addr

			asm
				"mov rax, 25" # mremap syscall
				"syscall"
			end

			__linux86_push_rax
		end



		func __linux86_munmap begin
			__linux86_pop_rsi # length
			__linux86_pop_rdi # addr

			asm
				"mov rax, 11" # munmap syscall
				"syscall"
			end

			__linux86_push_rax
		end

		func free begin
			dup 8 - @ swap 8 - swap 8 + __linux86_munmap
		end
	end
end
